1. Установка на 14.04

# Добавить реп
sudo sh -c 'echo "deb http://cran.rstudio.com/bin/linux/ubuntu trusty/" >> /etc/apt/sources.list'
gpg --keyserver keyserver.ubuntu.com --recv-key E084DAB9
gpg -a --export E084DAB9 | sudo apt-key add -
# поставить
sudo apt-get update 
sudo apt-get install r-base
# установка r-studio
sudo apt-get install libjpeg62 libcurl4-openssl-dev
wget https://download1.rstudio.org/rstudio-0.99.489-amd64.deb
sudo dpkg -i https://download1.rstudio.org/rstudio-0.99.489-amd64.deb

2. Установка пакетов

install.packages("xts")		# xts - пакет для работы с временными рядами
install.packages("xts", dependencies=TRUE)
install.packages("quantmod", repos="http://r-forge.r-project.org")		#с указанием репа

# для обновления пакетов: в меню r-studio tools->check for packets updates

3. Базовый синтаксис

# присваивание значений 
a = 5 
a <- 5
assign("a",5)

# стравнение значений (возвращает логические данные) 
a == b
a >= b

# сложение, вычитание 
a + b
a - b

# справка по функции
help($функция)	# в Rstudio - выделить и нажать F11
# тело функции 
body($функция)
# список параметров функции
formals($функция)

# задание собственной функции
my.fun1 <- function(x)		1 / (x+1) / sqrt(x)
# или так 
my.fun1 <- function(x) {
	z <- 1 / (x+1) / sqrt(x)
	return(z)
}

# оператор вывода
print("text")
# вывод в одну строку 
cat(i)


3.1 Работа с векторами

# задать вектор (структурированный набор значений)
a <- c(1,2,3,4,5,6:10)
b <- c(1, "a", T, F)
# или так
u <- seq(from=-2, to=3, by=0.5)	# from/to - диапазон, by - шаг сетки
u <- seq(-2, 3, length=11)	# length - длина вектора, шаг расчитывается автоматически

# задать вектор из повторяющихся значений
rep(1:3, 4)
rep(1:3, c(1,2,3))

b[1]	# 1-й элемент вектора
a[2:4]	# элементы с 2 по 4-й
lenght(v)	# длина вектора 
# с векторами можно работать практически всеми стандартными функциями
# при сложении/вычитании вектора должны быть кратны друг другу

# функции для работы с векторами
mean(x)	# вычисляет среднее
sum(x)
sum(x, na.rm=TRUE)	# позволяет исключить из вектора нечисловые значения
sd(x)	# вычисляет СКО (standart deviation)

# генерация random вектора 
# set.seed(10) - стандартизация последовательностей
open.cost = runif($длина, $min, $max)	# равномерный закон растпред-я
			rnorm(5, mean=2, sd=1)		# нормальное распред-е (mean - среднее, sd - дисперсия)

# кумулятивная сумма 
cumsum()

# количество положительных элементов
sum(x>0)

# объединение строк
rbind($имя_строки1=$данные1,
	  $имя_строки2=$данные2)
# объединение столбцов
cbind($имя_столбца1=$данные1,
	  $имя_столбца2=$данные2)

3.2 Листы

# лист может содержать в себе элементы любого вида
x <- list(1:3, "test", TRUE,list("f", "F"))

3.3 Даты

# В памяти хранятся относительные значения дат (от 01.01.1970)
# простой метод задать дату
as.Date('2015-05-13')
# или с указанием формата
as.Date('3/15/2015', format='%m/%d/%Y')

# относительное представление даты
a = as.Date('2015-05-13')
as.numeric(a)

# точное задание времени с часовым поясом
as.POSIXct("2013-09-12 12:05:05", tz="Europe/Moscow")	# в памяти хранит 1 число - кол-во секунд от относительной даты
POSIXlt	# в памяти хранится лист со значениями секунд, минут, часов, дней, месяцев, лет от относительной даты
as.POSIXct("12.09.2013 12:05:05",format="%d.%m.%Y %H:%M:%S" tz="UTC")

ISOdate(2014,11,28,19,11,37, tz="GMT")

# задать временную последовательность
seq(as.POSIXct("2014-10-10", by=month, length=4))	# зависит от часового пояса
seq(ISOdate(2014,10,10), ISOdate(2015,10,10), "days")	# GMT время



Sys.time()	# выводит системную дату и время
Sys.timezone()	# выводит системный часовой пояс
Sys.setenv(TZ='UTC')	# задает часовой пояс в окружении

3.4 Атрибуты

attr(a, "Myname") = "test"
attr(a, "Myname")	# выводит значение атрибута
attributes(a)	# выводит значения всех атрибутов переменной
names(x) = c("a", "b" ,"c") # пронаименовать вектор

3.5 Матрицы

# по-умолчанию элементы матрицы заполняются по строкам
# задать матрицу:
b = matrix(1:12,3,4)
b[2,2]	# обращение к конкретному элементу матрицы (строка/столбец, нумерация с 1)

#Включить заполнение по строкам:
a = matrix(data=1:12, nrow=3, ncol=4, byrow=T)

# умножение матрицы на число/вектор
a*b
# матричное умножение 
a %*% b
# транспонирование матрицы
t(a)

# Многомерные массивы
a=array(c(1:24), dim=c(1,2,3))

3.6 Фреймы

# Фрейм - матрица с  именованными столбцами

# Создать:
n = c(1,2,3)
a = c("a","b","c")
b = c(TRUE,FALSE,TRUE)
df = data.frame(n,a,b)	# функция создания фрейма
named(df) = c("N","String", "Flag")	# переименовать столбцы
df = data.frame(N=n, String=a, b=Flag)	# создать фрейм с нужными названиями

str(df)	# строковое представление фрейма
		# кол-во строк фрейма
ncol(df)	# кол-во столбцов фрейма
df[2,2]	# обращение к конкретному элементу фрейма
df[2]	# выделить столбец
df[,2:3] # выделить несколько столбцов
df[2,]	# выделить строку
df[df$Flag==TRUE]	# выделить строки столбца Flag, в которых значения TRUE

3.7 Файлы

# Задать текущий каталог
setwd("~/work/R")
getwd()	# вывести рабочий каталог

# Функция записи в файл
write.table()	
write.table(b, file="file.csv", sep="\t")	# запишет b в file.csv и разделит элементы табуляцией

# Функция чтения из файла 
a = read.table("file.csv")

# Функция для чтения .csv файлов
read.csv()
a = read.csv(unz("1.zip", "folder1/folder2/file.csv"))	# прочитать файл из архива

f = tempfile()	# создать temp file
download.file("http://site.com/file.zip", f)	# скачать архив
data = read.csv(unzip(f))
unlink(f)	# удалить temp

3.8 Ветвление & циклы

# простое ветвление
if ($условие) {
	$действие
}

# альтернативное ветвление
if ($условие) {
	$действие1			
} else {
	$действие2
}

# несколько альтернатив
if ($условие1) {
	$действие1			
} else if ($условие2) {
	$действие2
}

# цикл
for (i in 1:5) {
	print(i)
}

# цикл с предусловием 
k = 5 
while (k > 0) {
	cat(k, " ")
	k=k-1
}

# бесконечный цикл 
repeat {
	$действие1
	if ($условие_окончания) break
	$действие2
}

# вместо явных циклов
# применить для каждого элемента в:
sapply(v, sqrt)		# для векторов
lapply(v, sqrt)		# для листов
apply(v, 1, min)	# для матриц (найти min в строке)
apply(v, 1:2, min) 	# то же, но поэлементно
ifelse($условие, $true_действие, $false_действие)	# проверяет на соответствие все элементы вектора

seq_len(5)		# возвращает последовательность от 1 до n
seq_along(a)	# возвращает индексы всех элеменотов вектора "a", то же, что и seq_len(length(a)) 

3.9 Графики

# график функции
plot(x, type='o')
# график зависимости x от Y + сетка
plot(y, x, type='o'), grid()
# добавить еще один график к существующему
lines(y, y2)

# нарисовать горизонтальную линию
abline(h=20, col="red", lwd=2)
# нарисовать вертикальную линию
abline(h=20, col="red", lwd=2)

# гистаграмма
hist(x, breaks=x1, freq=F, xlab="", ylim=c(0, 0.5),	
	 ylab="плотность вероятности", main="Гистограмма")
# огибающая
lines(density(b3), col="$", lwd=$)

# график рядов из пакета zoo

plot.zoo(data[, c('equity', 'equity2')], type='1', plot.type='single', screens=c(1,1), col=c('blue', 'dark red'))


4. Пакеты для работы с временными рядами

	4.1 quantmod

	Позволяет получать кодировки с Yahoo Finance, Google Finance, локальной MySQL, .rdata, .rda, .csv и пр.

	# установка
	install.packages("quantmod", dependencies=TRUE)
	library(quantmod)

	# загрузка котировок
	getSymbols("MSFT", src="yahoo")
	# график котировок 
	chartSeries(MSFT)
	# график за период
	chartSeries(MSFT["2014-01/2014-04"])

		# преобразовать котировки в недельные
		to.weekly()
		# max значения
		hi(x)
		# min знаения
		lo(x)

	# свечной график
	candleChart(MSFT["2013/2014"], theme="black", up.col="green", dn.col="red")
	# барный график 
	barChart()

	# добавить SMA к графику
 	addSMA(n=20, on=1, col="blue")
 	# добавить линию
 	addLines(h=10, on=1,col="green")

 	# удалить линию с графика
 	dropTA("BBands")

 	# цены закрытия/открытия/hi/low/etc..
 	# столбцы фрейма должны содержать стандартные названия: Open”, “High”, “Low”, “Close”, “Volume”, or “Adjusted”
 	# при вызове данных функцией getSymbols(), названия фрейма прописываются правильно из-коробки
 	Op(x)
	Hi(x)
	Lo(x)
	Cl(x)
	Vo(x)
	Ad(x)

 	4.2 rusquant

 	Заточен под наши сервера. Позволяет загружать статистику по малоинтервальным данным - часы, минуты, секунды, тики.
 	По умолчанию загружается дневной график. Пакет поддерживается Финамом.
 	Не позволяет загружать большие объёмы данных. Грузить большие данные лучше в нерабочее время.

 	# установка
 	install.packages("rusquant", repos="http://r-forge.r-project.org", dependencies=TRUE)
 	library(rusquant)	
 	
 	# дополнительные варианты установки
 	install.packages("rusquant", contriburl="http://r-forge.r-project.org/bin/windows/contrib/latest/")
	# или из исходников:
	install.packages("rusquant", repos="http://R-Forge.R-project.org", type="source")
	# или скачать архив со страницы https://r-forge.r-project.org/R/?group_id=1175
	# и поставить из архива (Install from: Package Archive File).
	
	# загрузить данные
	getSymbols("SBER", from="2015-01-01", to=Sys.Date(), src="Finam")
	# загрузить данные с указанием периода
		# доступны периоды: 1min, 5min. 10min, 15min, 30min, hour, day, week, month
	getSymbols("SBER", from=Sys.Date()-1, src="Finam", period="5min")

	# построить график
	chartSeries(SBER, theme="black")
	# обавить exp-ю скользяшку (EMA)
	addEMA(n=20, col="blue")

	# загрузить тиковые данные
	getSymbols("SBER", from=Sys.Date()-1, src="Finam", period="tick")
	# тиковые данные можно преобразовать в лююые другие
	SBER_15min <- to.period(SBER, "mins", k=15)

	Данные можно получать с сайта mfd.ru и oanda.ru

	# загрузка списка доступных тикеров
	date("tikers")
	# поиск по тикерам
	tickers[grep("EUR")]

	# загрузка данных по тикерам
		# временные периоды такие же, как на Финаме
	getSymbols("EUR", from=Sys.Date()-1, src="mfd", period="hour", auto.assign=FALSE)

	4.3 quantmod

	4.4 xts

	# упорядочить по дате
	order.by=dt 

5. Простейшее тестирование стратегий
	
	5.1 Пересечение цены с SMA  (crossMA)

	library(rusquant)
	# для стандартизации имени функции данных
	s <- get(getSymbols("EUR/USD", src="oanda", from="2015-12-01", to="2015-12-10"))
	# переименовываем столбец (стобей данных только один - с oanda грузятся только цены закрытия)
	names(s) <- c("Close")
	# добавляем к данным еще один столбец со значениями SMA для 20 периодов
	s$sma20 <- SMA(Cl(s), 20)
	# необходимо определить, какую позицию открывать, исходя из пересечения SMA графиком цен
	# выбранную позицию записываем в доп. столбец
	s$position(ifelse(Cl(s)>s$sma20, 1, -1x	))
	# убрать из вектора строки-не числа
	# s <- s[!is.na(s$position),]
	s <- na.omit(s)
	# вычисление equity
	# лот 0.1, 1пункт = $1, для EURUSD 1пункт=0.0001
	s$ret <- lag(s$position)*(s$Close-lag(s$Close))*10000 
	# в первой строке - нулевая прибыль
	s[1,ret] = 0
	# кумулятивная сумма 
	s$equity <- cumsum(s$ret)
	plot(s$equity)

	5.2 Пересечение двух скользяшек (в примере - EMA) 
	
	data <- getSymbols("GAZP", from="2015-01-01", to="2015-12-01", src="Finam", period="15min", auto.assign=FALSE)
	head(data)
	names(data) <- c("Open" , "High" , "Low" , "Close" , "Volume")
	# вычисляем && записываем в вектор значения нужных EMA
	data$ema20 <- EMA(Cl(date), n=20)
	data$ema80 <- EMA(Cl(date), n=80)
	# входим в позицию
	data$position <- ifelse(data$ema20 >= data$ema80, 1, -1) 
	# удаление нечисловых значений
	data <- na.omit(data)
	# вычисление && график equity
	data$ret <- lag(data$position) * ( data$Close - lag(data$Close) )
	data$ret[1, "ret"] = 0
	data$equity <- cumsum(data$ret)
	plot(data.equity)

	5.3 Простейшая оптимизация
	
	# создать функцию
	test.strategy <- function(data, ema1, ema2, plot.show=TRUE) {
		data$ema1 <- EMA(Cl(data), n=ema1)
		data$ema2 <- EMA(Cl(data), n=ema2)
		data$position <- ifelse(data$ema20 >= data$ema80, 1, -1) 
		data <- na.omit(data)
		data$ret <- lag(data$position) * ( data$Close - lag(data$Close) )
		data$ret[1, "ret"] = 0
		data$equity <- cumsum(data$ret)
		if (plot.show) plot(data$equity)
		return(data$equity[[nrow(data)]])	
	}
	# задать цикл оптимизации
	smax <- -99999
	ema1.opt <- 0
	ema2.opt <- 0
	for (ema1 in seq (1, 99, 1) ) {
		for (ema2 in seq (ema1+1, 100, 1) ) {
			s <- test.strategy(data, ema1, ema2, FALSE)
			if (s > smax) {smax <- s
							ema1.opt <- ema1
							ema2.opt <- ema2
			}
		}
	if ( ema1 %% 10 == 0 ) cat ( ema1 , " " , sep="" )
	}

 	# все пары чисел n1 и n2
	g <- as.matrix(expand.grid(n1,n2))
	eq <- apply(g, 1, function(r) test1(data, r[1], r[2], FALSE))
	# Номер строки , для которой э к в и т и максимальна :
	opt.ind <- which.max(eq)
	# Параметры в э то й с т р о к е :
	g.opt <- g[opt.ind, ]
	g.opt
	test1(data, g.opt[1], g.opt[2], TRUE)

	5.3 Учёт накладных расходов

	#
	# на примере стратегии пересечения цены со скользящей средней
	#
	library(rusquant)
	data <- getSymbols("EURUSD", from=Sys.Date() -3, to=Sys.Date(),
		src="Finam", period="15min", auto.assign=FALSE)
	head(data, 3)
	names(data) <- c("Open", "High", "Low", "Close", "Volume")
	# можно и так переименовать: colnames(data) <- gsub(".*\\.", "", colnames(data))
	# копия данных
	data2 <- data
	head(data2, 3)
	# вычеслить EMA
	data2$ma1 <- EMA( Cl(data), 50) 
	# параметр нормирования по пунктам
	pip <- 0.0001
	# "мёртвая зона" вокруг EMA
	delta <- 3*pip
	# алгоритм стратегии
	data2$pos <- ifelse(data2$Close > data2$ma+delta, 1, 
						ifelse(data2$Close < data2$ma-delta, -1, 0) )
	data2 <- na.omit(data2) # убрали строки с NA
	# результаты сделок
	data2$ret <- lag(data2$pos)*(data2$Close-lag(data2$Close))/pip
	data2[1, "ret"] = 0 # в первой строке нулевая прибыль
	# equity
	data2$equity <- cumsum(data2$ret) 
	n <- nrow(data2) # количество строк
	s <- data2$equity[[n]] # конечная сумма без учёта накладных расходов
	# расчет накладных расходов
	# количество сделок (входов)
	y <- ifelse ( (data2$pos != lag(data2$pos)), abs(data2$pos), 0)	# определение перехода
	y[1] <- 0 # вместо NA.
	# k - число сделок
	k <- sum(y, na.rm=TRUE)+1
	spread <- 2 # спред 2 пункта .
	commiss <- 1 # комиссия на круг (в пересчёте на пункты)
	slip <- 2 # проскальзывание 1 пункт при входе и 1 пункт при выходе
	# все накладные расходы (в пунктах)
	overheads <- k*(spread+commiss+slip)
	# итоговая прибыль/убыток
	s2 <- s - overheads

	# всё это в виде функции
	test3 <- function(data, n, pip=0.0001 , delta=3) {
		data$ma1 <- EMA (Cl(data), n)
		delta2 <- delta*pip
		data$pos <- ifelse(	data$Close > data$ma+delta2, 1,
							ifelse(data$Close < data$ma-delta2, -1, 0) )
		data <- na.omit(data)
		data$ret <- lag(data$pos)*(data$Close-lag(data$Close))/pip
		data[1, "ret"] = 0
		data$equity <- cumsum(data$ret)
		m <- nrow(data)
		s <- data$equity[ [m] ] 
		y <- ifelse( (data$pos != lag(data$pos)), abs(data$pos), 0 )
		y[1] <- 0 
		k <- sum(y, na.rm=TRUE)+1
		spread <- 2
		commiss <- 1 
		slip <- 2
		overheads <- k*(spread+commiss+slip)
		s2 <- s-overheads # прибыль с учётом накл. расходов
		return (c(s, s2, k))
	}

	5.4 Оптимизация функций с двумя параметрами (опт. двух параметров одновременно)
    # функцию test3 на период EMA и "мертвой зоны"
   	n <- seq(10, 300, by=5)
	delta <- seq(-10, 20, by=1)
	# матрица тестовых значений
	g <- as.matrix(expand.grid(n, delta))
	# тест
	y <- apply(g, 1, function(r) test3(data, n=r[1], delta=r[2]) )
	# выделяем строку с equity после учёта комиссий
	s <- y[2, ]
	# Ищем максимальный элемент :
	k.opt <- which.max(s)
	g.opt <- g[k.opt, ]
	n.opt <- g.opt[[1]]
	delta.opt <- g.opt[[2]]
	n.opt; delta.opt	# вывод данных
	test3(data, n.opt, delta=delta.opt)	# проверка 

6. Графики функций с 2-мя переменными
	
	6.1 Изометрические графики

	y <- x <- seq(-10, 10, length=30)
	f <- function (x, y) { 
		r=sqrt(x^2+y^2) 
		10*sin(r)/r 
		}
	# построение матрицы со значениями параметров и функции
	z = outer(x, y, f) # Получили матрицу 30 x 3 0 .
	# расцветка графика
	col <- rainbow(30, start=0.05, end=0.75)
	# функция рисования графика
	persp(x, y, z, col=col, theta=55, phi=25)

	# параметры полотна графика (здесь разбиваем полотно на матрицу графиков)
	par(	mfrow = c(2, 3), # будем выводить графики в матрице 2x3
			oma = c(0, 0, 0, 0), # поля для всего листа графиков
			mar = c(0, 0, 0, 0) # поля сверху или справа от графика 
	) 
	# графики
	# 1-й
	persp(x, y, z, col=’lightgreen’, theta=50, phi=30)	# 1-й
	# 2-й
	col <- rainbow(30, start=0 , end = 0.95)
	persp(x, y, z, col=col , theta=50 , phi=30)
	# 3-й
	col <- heat.colors(30)
	persp(x, y, z, col=col, theta=50, phi=30) 
	# 4-й
	col <- terrain.colors(30)
	persp(x, y, z, col=col, theta=50, phi=30)
	# 5-й
	col <- topo.colors(30)
	persp(x, y, z, col=col, theta=50, phi=30)
	# 6-й
	col <- cm.colors(30)
	persp(x, y, z, col=col, theta=50, phi=30)
	
	# пакет rgl
	library (rgl)
	persp3d (x, y, z1, col=rainbow(length(x)) )

	6.1 3D-графики 

#####
	# пакет plot3D
	#
	library (plot3D)
	persp3D (x, y, z1, contour=TRUE)

	# 3D-гистаграмма
	x2 <- y2 <- seq(-4, 4, by = 0.5)
	f2 <- function( x2, y2 ) { (25-(x2^2-y2^2) ) }
	z2 <- outer(x2, y2, f2)
	par( mfrow = c(1, 1), oma = c(2, 2, 2, 2) )
	hist3D(x2, y2, z2, border = "black")

	# 2D график (для функции с 2-мя переменными)
	library (plot3D)
	image2D (z2, x2, y2)
	image2D (z2, x2, y2, contour=TRUE)

#####
	# пакет rgl
	#
	library(rgl)
	rgl.open( ); bg3d("white")
	plot3d(g[ ,1], z3, g[ ,2], labels=labels, type="s",
			size=2, lwd=2, col=rainbow(length(g[ , 2])) )
	identify3d (g [ , 1], z3, g[ , 2], labels=labels)
	# щёлкаем правой кнопкой мыши по любой точке
	# средняя кнопка - выход из режима
	rgl.close() 

#####
	# пакет car
	#
	library ( car )
	rgl.open()
	scatter3d(g[ ,1], z3, g[ ,2], labels=labels, neg.res.col="grey", pos.res.col=rainbow(1 0 0 0 ), point.col="black")

7. Учёт сделок
	
#####
	# при работе с временными рядами
	#
	# нумирация трейдов
	TradeID <- function(states) {
		x <- diff(states); x[1] <- states[1]
		cumsum( as.numeric( as.logical(abs(x)) & abs(states) )) * abs(states)
	}

	# учёт входов
	TradeEntries <- function(states) {
		x <- diff(states)
		x[1] <- states[1]
		as.numeric(as.logical(x) * states)
	}

	# учёт выходов
	TradeExits <- function(states) {
		x <- as.numeric( as.logical( diff(states) * lag(states) ))
		x[1] <- 0
		x
	}

	#смена позиции 
	TradeCh <- function(states) {
		x <- diff(states)
		x[1] <- states[1]
		return(x)
	}

	
##### при работе с векторами
	#
	# нумерация трейдов
	TradeID <- function(states) {
		cumsum( as.numeric( as.logical( abs(c(states[1], diff(states)))) & abs(states) )) * abs(states)
	}

	# учёт входов 
	TradeEntries <- function(states) {
		as.numeric( as.logical(c(states[1], diff(states))) * states )
	}

	# учёт выходов
	TradeExits <- function(states) {
		as.numeric( c(FALSE, as.logical( diff(states) * states[-length(states)] )))
	}

	# смена позиции
	TradeCh <- function(states) {
		c(states[1], diff(states))
	}

##### проверка ветора "states" на правильность значений
	#
	if(!all( states %in% c(-1,0,1) )) {
		stop("states must be a numeric vector with -1,0,1")
	}

##### пересечение линий
	#
	# для векторов
	Сross <- function(x1,x2) {
		x <- diff(x1>x2)
		x[1] <- 0
		x[x<0] <- 0
		as.logical(c(0,x))
	}
	# для рядов
	Cross <- function(x1,x2) {
		x <- diff(x1>x2)
		x[1] <- 0
	}