1. Установка на 14.04

# Добавить реп
sudo sh -c 'echo "deb http://cran.rstudio.com/bin/linux/ubuntu trusty/" >> /etc/apt/sources.list'
gpg --keyserver keyserver.ubuntu.com --recv-key E084DAB9
gpg -a --export E084DAB9 | sudo apt-key add -
# поставить
sudo apt-get update 
sudo apt-get install r-base
# установка r-studio
sudo apt-get install libjpeg62 libcurl4-openssl-dev
wget https://download1.rstudio.org/rstudio-0.99.489-amd64.deb
sudo dpkg -i https://download1.rstudio.org/rstudio-0.99.489-amd64.deb

2. Установка пакетов

install.packages("xts")		# xts - пакет для работы с временными рядами
install.packages("xts", dependencies=TRUE)
install.packages("quantmod", repos="http://r-forge.r-project.org")		#с указанием репа

# для обновления пакетов: в меню r-studio tools->check for packets updates

3. Базовый синтаксис

# присваивание значений 
a = 5 
a <- 5
assign("a",5)

# стравнение значений (возвращает логические данные) 
a == b
a >= b

# сложение, вычитание 
a + b
a - b

# справка по функции
help($функция)	# в Rstudio - выделить и нажать F11
# тело функции 
body($функция)
# список параметров функции
formals($функция)

# задание собственной функции
my.fun1 <- function(x)		1 / (x+1) / sqrt(x)
# или так 
my.fun1 <- function(x) {
	z <- 1 / (x+1) / sqrt(x)
	return(z)
}

# оператор вывода
print("text")
# вывод в одну строку 
cat(i)

3.1 Работа с векторами

# задать вектор (структурированный набор значений)
a <- c(1,2,3,4,5,6:10)
b <- c(1, "a", T, F)
# или так
u <- seq(from=-2, to=3, by=0.5)	# from/to - диапазон, by - шаг сетки
u <- seq(-2, 3, length=11)	# length - длина вектора, шаг расчитывается автоматически

# задать вектор из повторяющихся значений
rep(1:3, 4)
rep(1:3, c(1,2,3))

b[1]	# 1-й элемент вектора
a[2:4]	# элементы с 2 по 4-й
lenght(v)	# длина вектора 
# с векторами можно работать практически всеми стандартными функциями
# при сложении/вычитании вектора должны быть кратны друг другу

# функции для работы с векторами
mean(x)	# вычисляет среднее
sum(x)
sum(x, na.rm=TRUE)	# позволяет исключить из вектора нечисловые значения
sd(x)	# вычисляет СКО (standart deviation)

# генерация random вектора 
# set.seed(10) - стандартизация последовательностей
open.cost = runif($длина, $min, $max)	# равномерный закон растпред-я
			rnorm(5, mean=2, sd=1)		# нормальное распред-е (mean - среднее, sd - дисперсия)

# кумулятивная сумма 
cumsum()

# количество положительных элементов
sum(x>0)

3.2 Листы

# лист может содержать в себе элементы любого вида
x <- list(1:3, "test", TRUE,list("f", "F"))

3.3 Даты

# В памяти хранятся относительные значения дат (от 01.01.1970)
# простой метод задать дату
as.Date('2015-05-13')
# или с указанием формата
as.Date('3/15/2015', format='%m/%d/%Y')

# относительное представление даты
a = as.Date('2015-05-13')
as.numeric(a)

# точное задание времени с часовым поясом
as.POSIXct("2013-09-12 12:05:05", tz="Europe/Moscow")	# в памяти хранит 1 число - кол-во секунд от относительной даты
POSIXlt	# в памяти хранится лист со значениями секунд, минут, часов, дней, месяцев, лет от относительной даты
as.POSIXct("12.09.2013 12:05:05",format="%d.%m.%Y %H:%M:%S" tz="UTC")

ISOdate(2014,11,28,19,11,37, tz="GMT")

# задать временную последовательность
seq(as.POSIXct("2014-10-10", by=month, length=4))	# зависит от часового пояса
seq(ISOdate(2014,10,10), ISOdate(2015,10,10), "days")	# GMT время



Sys.time()	# выводит системную дату и время
Sys.timezone()	# выводит системный часовой пояс
Sys.setenv(TZ='UTC')	# задает часовой пояс в окружении

3.4 Атрибуты

attr(a, "Myname") = "test"
attr(a, "Myname")	# выводит значение атрибута
attributes(a)	# выводит значения всех атрибутов переменной
names(x) = c("a", "b" ,"c") # пронаименовать вектор

3.5 Матрицы

# по-умолчанию элементы матрицы заполняются по строкам
# задать матрицу:
b = matrix(1:12,3,4)
b[2,2]	# обращение к конкретному элементу матрицы (строка/столбец, нумерация с 1)

#Включить заполнение по строкам:
a = matrix(data=1:12, nrow=3, ncol=4, byrow=T)

# умножение матрицы на число/вектор
a*b
# матричное умножение 
a %*% b
# транспонирование матрицы
t(a)

# Многомерные массивы
a=array(c(1:24), dim=c(1,2,3))

3.6 Фреймы

# Фрейм - матрица с  именованными столбцами

# Создать:
n = c(1,2,3)
a = c("a","b","c")
b = c(TRUE,FALSE,TRUE)
df = data.frame(n,a,b)	# функция создания фрейма
named(df) = c("N","String", "Flag")	# переименовать столбцы
df = data.frame(N=n, String=a, b=Flag)	# создать фрейм с нужными названиями

str(df)	# строковое представление фрейма
		# кол-во строк фрейма
ncol(df)	# кол-во столбцов фрейма
df[2,2]	# обращение к конкретному элементу фрейма
df[2]	# выделить столбец
df[,2:3] # выделить несколько столбцов
df[2,]	# выделить строку
df[df$Flag==TRUE]	# выделить строки столбца Flag, в которых значения TRUE

3.7 Файлы

# Задать текущий каталог
setwd("~/work/R")
getwd()	# вывести рабочий каталог

# Функция записи в файл
write.table()	
write.table(b, file="file.csv", sep="\t")	# запишет b в file.csv и разделит элементы табуляцией

# Функция чтения из файла 
a = read.table("file.csv")

# Функция для чтения .csv файлов
read.csv()
a = read.csv(unz("1.zip", "folder1/folder2/file.csv"))	# прочитать файл из архива

f = tempfile()	# создать temp file
download.file("http://site.com/file.zip", f)	# скачать архив
data = read.csv(unzip(f))
unlink(f)	# удалить temp

3.8 Ветвление & циклы

# простое ветвление
if ($условие) {
	$действие
}

# альтернативное ветвление
if ($условие) {
	$действие1			
} else {
	$действие2
}

# несколько альтернатив
if ($условие1) {
	$действие1			
} else if ($условие2) {
	$действие2
}

# цикл
for (i in 1:5) {
	print(i)
}

# цикл с предусловием 
k = 5 
while (k > 0) {
	cat(k, " ")
	k=k-1
}

# бесконечный цикл 
repeat {
	$действие1
	if ($условие_окончания) break
	$действие2
}

# вместо явных циклов
sapply(v, sqrt)		# для векторов
lapply(v, sqrt)		# для листов
apply(v, 1, min)	# для матриц (найти min в строке)
apply(v, 1:2, min) 	# то же, но поэлементно
ifelse($условие, $true_действие, $false_действие)	# проверяет на соответствие все элементы вектора

seq_len(5)		# возвращает последовательность от 1 до n
seq_along(a)	# возвращает индексы всех элеменотов вектора "a", то же, что и seq_len(length(a)) 

3.9 Графики

# график функции
plot(x, type='o')
# график зависимости x от Y + сетка
plot(y, x, type='o'), grid()
# добавить еще один график к существующему
lines(y, y2)

# нарисовать горизонтальную линию
abline(h=20, col="red", lwd=2)
# нарисовать вертикальную линию
abline(h=20, col="red", lwd=2)

# гистаграмма
hist(x, breaks=x1, freq=F, xlab="", ylim=c(0, 0.5),	
	 ylab="плотность вероятности", main="Гистограмма")
# огибающая
lines(density(b3), col="$", lwd=$)


4. Пакеты 

	4.1 quantmod

	Позволяет получать кодировки с Yahoo Finance, Google Finance, локальной MySQL, .rdata, .rda, .csv и пр.

	# установка
	install.packages("quantmod", dependencies=TRUE)
	library(quantmod)

	# загрузка котировок
	getSymbols("MSFT", src="yahoo")
	# график котировок 
	chartSeries(MSFT)
	# график за период
	chartSeries(MSFT["2014-01/2014-04"])

		# преобразовать котировки в недельные
		to.weekly()
		# max значения
		hi(x)
		# min знаения
		lo(x)

	# свечной график
	candleChart(MSFT["2013/2014"], theme="black", up.col="green", dn.col="red")
	# барный график 
	barChart()

	# добавить SMA к графику
 	addSMA(n=20, on=1, col="blue")
 	# добавить линию
 	addLines(h=10, on=1,col="green")

 	# удалить линию с графика
 	dropTA("BBands")

 	# цены закрытия/открытия/hi/low/etc..
 	# столбцы фрейма должны содержать стандартные названия: Open”, “High”, “Low”, “Close”, “Volume”, or “Adjusted”
 	# при вызове данных функцией getSymbols(), названия фрейма прописываются правильно из-коробки
 	Op(x)
	Hi(x)
	Lo(x)
	Cl(x)
	Vo(x)
	Ad(x)

 	4.2 rusquant

 	Заточен под наши сервера. Позволяет загружать статистику по малоинтервальным данным - часы, минуты, секунды, тики.
 	По умолчанию загружается дневной график. Пакет поддерживается Финамом.
 	Не позволяет загружать большие объёмы данных. Грузить большие данные лучше в нерабочее время.

 	# установка
 	install.packages("rusquant", repos="http://r-forge.r-project.org", dependencies=TRUE)
 	library(rusquant)	
 	
 	# дополнительные варианты установки
 	install.packages("rusquant", contriburl="http://r-forge.r-project.org/bin/windows/contrib/latest/")
	# или из исходников:
	install.packages("rusquant", repos="http://R-Forge.R-project.org", type="source")
	# или скачать архив со страницы https://r-forge.r-project.org/R/?group_id=1175
	# и поставить из архива (Install from: Package Archive File).
	
	# загрузить данные
	getSymbols("SBER", from="2015-01-01", to=Sys.Date(), src="Finam")
	# загрузить данные с указанием периода
		# доступны периоды: 1min, 5min. 10min, 15min, 30min, hour, day, week, month
	getSymbols("SBER", from=Sys.Date() -1, src="Finam", period="5min")

	# построить график
	chartSeries(SBER, theme="black")
	# обавить exp-ю скользяшку (EMA)
	addEMA(n=20, col="blue")

	# загрузить тиковые данные
	getSymbols("SBER", from=Sys.Date()-1, src="Finam", period="tick")
	# тиковые данные можно преобразовать в лююые другие
	SBER_15min <- to.period(SBER, "mins", k=15)

	Данные можно получать с сайта mfd.ru и oanda.ru

	# загрузка списка доступных тикеров
	date("tikers")
	# поиск по тикерам
	tickers[grep("EUR")]

	# загрузка данных по тикерам
		# временные периоды такие же, как на Финаме
	getSymbols("EUR", from=Sys.Date()-1, src="mfd", period="hour", auto.assign=FALSE)

	4.3 quantmod

5. Простейшее тестирование стратегий
	
	5.1 Пересечение цены с SMA  (crossMA)

	library(rusquant)
	# для стандартизации имени функции данных
	s <- get(getSymbols("EUR/USD", src="oanda", from="2015-12-01", to="2015-12-10"))
	# переименовываем столбец (стобей данных только один - с oanda грузятся только цены закрытия)
	names(s) <- c("Close")
	# добавляем к данным еще один столбец со значениями SMA для 20 периодов
	s$sma20 <- SMA(Cl(s), 20)
	# необходимо определить, какую позицию открывать, исходя из пересечения SMA графиком цен
	# выбранную позицию записываем в доп. столбец
	s$position(ifelse(Cl(s)>s$sma20, 1, -1x	))
	# убрать из вектора строки-не числа
	# s <- s[!is.na(s$position),]
	s <- na.omit(s)
	# вычисление equity
	# лот 0.1, 1пункт = $1, для EURUSD 1пункт=0.0001
	s$ret <- lag(s$position)*(s$Close-lag(s$Close))*10000 
	# в первой строке - нулевая прибыль
	s[1,ret] = 0
	# кумулятивная сумма 
	s$equity <- cumsum(s$ret)
	plot(s$equity)

