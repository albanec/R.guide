1. Установка на 14.04

# Добавить реп
sudo sh -c 'echo "deb http://cran.rstudio.com/bin/linux/ubuntu trusty/" >> /etc/apt/sources.list'
gpg --keyserver keyserver.ubuntu.com --recv-key E084DAB9
gpg -a --export E084DAB9 | sudo apt-key add -
# поставить
sudo apt-get update 
sudo apt-get install r-base
# установка r-studio
sudo apt-get install libjpeg62 libcurl4-openssl-dev
wget https://download1.rstudio.org/rstudio-0.99.489-amd64.deb
sudo dpkg -i https://download1.rstudio.org/rstudio-0.99.489-amd64.deb

2. Установка пакетов

install.packages("xts")		# xts - пакет для работы с временными рядами
install.packages("xts", dependencies=TRUE)
install.packages("quantmod", repos="http://r-forge.r-project.org")		#с указанием репа

# для обновления пакетов: в меню r-studio tools->check for packets updates

3. Базовый синтаксис

# присваивание значений 
a = 5 
a <- 5
assign("a",5)

# стравнение значений (возвращает логические данные) 
a == b
a >= b

# сложение, вычитание 
a + b
a - b

# справка по функции
help($функция)	# в Rstudio - выделить и нажать F11
# тело функции 
body($функция)
# список параметров функции
formals($функция)

# задание собственной функции
my.fun1 <- function)(x)		1 / (x+1) / sqrt(x)
# или так 
my.fun1 <- function(x) {
	z <- 1 / (x+1) / sqrt(x)
	return(z)
}

# оператор вывода
print("text")
# вывод в одну строку 
cat(i)

3.1 Работа с векторами

# задать вектор (структурированный набор значений)
a <- c(1,2,3,4,5,6:10)
b <- c(1, "a", T, F)
# или так
u <- seq(from=-2, to=3, by=0.5)	# from/to - диапазон, by - шаг сетки
u <- seq(-2, 3, length=11)	# length - длина вектора, шаг расчитывается автоматически

# задать вектор из повторяющихся значений
rep(1:3, 4)
rep(1:3, c(1,2,3))

b[1]	# 1-й элемент вектора
a[2:4]	# элементы с 2 по 4-й
lenght(v)	# длина вектора 
# с векторами можно работать практически всеми стандартными функциями
# при сложении/вычитании вектора должны быть кратны друг другу

# функции для работы с векторами
mean(x)	# вычисляет среднее
sum(x)
sum(x, na.rm=TRUE)	# позволяет исключить из вектора нечисловые значения

3.2 Листы

# лист может содержать в себе элементы любого вида
x <- list(1:3, "test", TRUE,list("f", "F"))

3.3 Даты

# В памяти хранятся относительные значения дат (от 01.01.1970)
# простой метод задать дату
as.Date('2015-05-13')
# или с указанием формата
as.Date('3/15/2015', format='%m/%d/%Y')

# относительное представление даты
a = as.Date('2015-05-13')
as.numeric(a)

# точное задание времени с часовым поясом
as.POSIXct("2013-09-12 12:05:05", tz="Europe/Moscow")	# в памяти хранит 1 число - кол-во секунд от относительной даты
POSIXlt	# в памяти хранится лист со значениями секунд, минут, часов, дней, месяцев, лет от относительной даты
as.POSIXct("12.09.2013 12:05:05",format="%d.%m.%Y %H:%M:%S" tz="UTC")

ISOdate(2014,11,28,19,11,37, tz="GMT")

# задать временную последовательность
seq(as.POSIXct("2014-10-10", by=month, length=4))	# зависит от часового пояса
seq(ISOdate(2014,10,10), ISOdate(2015,10,10), "days")	# GMT время



Sys.time()	# выводит системную дату и время
Sys.timezone()	# выводит системный часовой пояс
Sys.setenv(TZ='UTC')	# задает часовой пояс в окружении

3.4 Атрибуты

attr(a, "Myname") = "test"
attr(a, "Myname")	# выводит значение атрибута
attributes(a)	# выводит значения всех атрибутов переменной
names(x) = ("a", "b" ,"c") # пронаименовать вектор

3.5 Матрицы

# по-умолчанию элементы матрицы заполняются по строкам
# задать матрицу:
b = matrix(1:12,3,4)
b[2,2]	# обращение к конкретному элементу матрицы (строка/столбец, нумерация с 1)

#Включить заполнение по строкам:
a = matrix(data=1:12, nrow=3, ncol=4, byrow=T)

# умножение матрицы на число/вектор
a*b
# матричное умножение 
a %*% b
# транспонирование матрицы
t(a)

# Многомерные массивы
a=array(c(1:24), dim=c(1,2,3))

3.6 Фреймы

# Фрейм - матрица с  именованными столбцами

# Создать:
n = c(1,2,3)
a = c("a","b","c")
b = c(TRUE,FALSE,TRUE)
df = data.frame(n,a,b)	# функция создания фрейма
named(df) = c("N","String", "Flag")	# переименовать столбцы
df = data.frame(N=n, String=a, b=Flag)	# создать фрейм с нужными названиями

str(df)	# строковое представление фрейма
		# кол-во строк фрейма
ncol(df)	# кол-во столбцов фрейма
df[2,2]	# обращение к конкретному элементу фрейма
df[2]	# выделить столбец
df[,2:3] # выделить несколько столбцов
df[2,]	# выделить строку
df[df$Flag==TRUE]	# выделить строки столбца Flag, в которых значения TRUE

3.7 Файлы

# Задать текущий каталог
setwd("~/work/R")
getwd()	# вывести рабочий каталог

# Функция записи в файл
write.table()	
write.table(b, file="file.csv", sep="\t")	# запишет b в file.csv и разделит элементы табуляцией

# Функция чтения из файла 
a = read.table("file.csv")

# Функция для чтения .csv файлов
read.csv()
a = read.csv(unz("1.zip", "folder1/folder2/file.csv"))	# прочитать файл из архива

f = tempfile()	# создать temp file
download.file("http://site.com/file.zip", f)	# скачать архив
data = read.csv(unzip(f))
unlink(f)	# удалить temp

3.8 Ветвление & циклы

# простое ветвление
if ($условие) {
	$действие
}

# альтернативное ветвление
if ($условие) {
	$действие1			
} else {
	$действие2
}

# несколько альтернатив
if ($условие1) {
	$действие1			
} else if ($условие2) {
	$действие2
}

# цикл
for (i in 1:5) {
	print(i)
}

# цикл с предусловием 
k = 5 
while (k > 0) {
	cat(k, " ")
	k=k-1
}

# бесконечный цикл 
repeat {
	$действие1
	if ($условие_окончания) break
	$действие2
}

# вместо явных циклов
sapply(v, sqrt)		# для векторов
lapply(v, sqrt)		# для листов
apply(v, 1, min)	# для матриц (найти min в строке)
apply(v, 1:2, min) 	# то же, но поэлементно


seq_len(5)		# возвращает последовательность от 1 до n
seq_along(a)	# возвращает индексы всех элеменотов вектора "a", то же, что и seq_len(length(a)) 
